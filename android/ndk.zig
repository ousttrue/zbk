const std = @import("std");

pub const PathOpts = union(enum) {
    android_home: []const u8,
};

pub fn getPath(allocator: std.mem.Allocator, opts: PathOpts) ![]const u8 {
    switch (opts) {
        .android_home => |android_home| {
            var root = try std.fs.openDirAbsolute(android_home, .{});
            defer root.close();

            var ndk_dir = try root.openDir("ndk", .{ .iterate = true });
            defer ndk_dir.close();

            var it = ndk_dir.iterate();
            var version: []const u8 = "";
            while (try it.next()) |entry| {
                if (std.mem.order(
                    u8,
                    entry.name,
                    version,
                ) == .gt) {
                    version = entry.name;
                }
            }
            if (version.len == 0) {
                return error.no_ndk;
            }

            return std.fmt.allocPrint(allocator, "{s}/ndk/{s}", .{ android_home, version });
        },
    }
}

pub const LibCFile = struct {
    step: *std.Build.Step,
    path: std.Build.LazyPath,
    include_dir: []const u8,
    sys_include_dir: []const u8,
    crt_dir: []const u8,

    pub fn make(
        b: *std.Build,
        ndk_path: []const u8,
        target: std.Build.ResolvedTarget,
        android_api_level: u8,
    ) !@This() {
        const libc_file_format =
            \\# Generated by zig-android-sdk. DO NOT EDIT.
            \\
            \\# The directory that contains `stdlib.h`.
            \\# On POSIX-like systems, include directories be found with: `cc -E -Wp,-v -xc /dev/null`
            \\include_dir={[include_dir]s}
            \\
            \\# The system-specific include directory. May be the same as `include_dir`.
            \\# On Windows it's the directory that includes `vcruntime.h`.
            \\# On POSIX it's the directory that includes `sys/errno.h`.
            \\sys_include_dir={[sys_include_dir]s}
            \\
            \\# The directory that contains `crt1.o`.
            \\# On POSIX, can be found with `cc -print-file-name=crt1.o`.
            \\# Not needed when targeting MacOS.
            \\crt_dir={[crt_dir]s}
            \\
            \\# The directory that contains `vcruntime.lib`.
            \\# Only needed when targeting MSVC on Windows.
            \\msvc_lib_dir=
            \\
            \\# The directory that contains `kernel32.lib`.
            \\# Only needed when targeting MSVC on Windows.
            \\kernel32_lib_dir=
            \\
            \\gcc_dir=
        ;
        const triple: []const u8 = try target.result.linuxTriple(b.allocator);
        const sysroot_dir = getSysroot(b, ndk_path);
        const include_dir = b.fmt("{s}/usr/include", .{sysroot_dir});
        const sys_include_dir = b.fmt("{s}/usr/include/{s}", .{ sysroot_dir, triple });
        const crt_dir = b.fmt("{s}/usr/lib/{s}/{}", .{ sysroot_dir, triple, android_api_level });
        const libc_file_contents = b.fmt(libc_file_format, .{
            .include_dir = include_dir,
            .sys_include_dir = sys_include_dir,
            .crt_dir = crt_dir,
        });
        const wf = b.addWriteFiles();
        return .{
            .step = &wf.step,
            .path = wf.add("libc.conf", libc_file_contents),
            .include_dir = include_dir,
            .sys_include_dir = sys_include_dir,
            .crt_dir = crt_dir,
        };
    }
};

fn getSysroot(b: *std.Build, ndk_path: []const u8) []const u8 {
    return if (b.graph.host.result.os.tag == .windows)
        b.fmt("{s}/toolchains/llvm/prebuilt/windows-x86_64/sysroot", .{ndk_path})
    else
        b.fmt("{s}/toolchains/llvm/prebuilt/linux-x86_64/sysroot", .{ndk_path});
}
